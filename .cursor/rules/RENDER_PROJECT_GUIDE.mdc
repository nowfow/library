---
alwaysApply: true
---

Общая архитектура

- **Frontend:** Vue.js (SPA, PWA), деплоится на Render
- **Backend:** Node.js (Express), деплоится на Render
- **База данных:** MySQL (отдельный хостинг, не Render). В базе хранятся: Вот документации базы данные [TERMS_DB_GUIDE.mdc](mdc:.cursor/rules/TERMS_DB_GUIDE.mdc)
- Иерархия произведений (структура каталога, метаданные, пути к файлам)
- Таблица terms (термины для справочника)
- Таблица сопоставления миниатюр PDF (путь к PDF, путь к миниатюре)
- **Файлы нот и миниатюр:** Хранятся на облачном хранилище WebDAV (cloud.mail.ru)
- Папки с нотами (PDF)
- Папка с миниатюрами (thumbnails)


## Взаимодействие компонентов

- **Vue.js frontend** (SPA, PWA) запрашивает данные у backend (API):
- Получение списка произведений, нот, поиска и т.д.
- Получение списка терминов
- Получение путей к миниатюрам и нотам
- **Backend (Node.js + Express):**
- Получает данные из MySQL (через mysql2 или аналогичный драйвер)
- Отдаёт клиенту только метаданные и пути (не сами файлы)
- Для миниатюр и нот отдаёт клиенту путь для загрузки по WebDAV
- **WebDAV:**
- Фронтенд (или backend-прокси) скачивает PDF/миниатюру по ссылке WebDAV (авторизация через токен/логин)
- Миниатюры лежат в папке thumbnails, имена — md5 от относительного пути к PDF


## Примеры сценариев работы

### 1. Карусель нот конкретного композитора
- Пользователь заходит на сайт (Vue SPA, PWA).
- Фронтенд делает запрос к backend: "дай список произведений Моцарта".
- Backend возвращает массив: [{"title": ..., "composer": ..., "pdf_path": ..., "thumbnail_path": ...}, ...]
- Фронтенд отображает карточки: миниатюра (загружается по WebDAV, путь берётся из thumbnail_path), название, композитор.
- При клике на карточку:
- Фронтенд получает путь к PDF (из базы), загружает файл по WebDAV и открывает во внутреннем просмотрщике (pdf.js).
### 2. Страница терминов
- Пользователь открывает страницу терминов.
- Фронтенд делает запрос к backend: "дай все термины" или "поиск по термину".
- Backend делает SQL-запрос к MySQL, возвращает результаты.
- Фронтенд отображает термины и их описания.


## Используемые технологии

- **Frontend:** Vue.js, pdf.js (для отображения PDF), Tailwind CSS, PWA (Service Worker, Web App Manifest), Vue Router, Axios
- **Backend:** Node.js, Express.js, MySQL2, webdav-client, Axios
- **БД:** MySQL (отдельный хостинг)
- **Файлы:** WebDAV (cloud.mail.ru)
- **Деплой:** Render (frontend, backend), внешний хостинг для MySQL, подключение по WebDAV
- **PWA:** offline режим, установка на устройство, push-уведомления, кэширование статики и API-ответов


## Важные детали для реализации

- Все пути к файлам и миниатюрам в базе — относительные, начинаются с `/`, используют `/` как разделитель.
- Миниатюры не дублируются, поиск по md5 — быстрый (можно строить индекс в памяти или использовать отдельную таблицу в БД).
- Для отдачи 30 миниатюр за раз — backend делает SQL-запрос с LIMIT, отдаёт массив путей к миниатюрам и метаданных.
- Для загрузки файлов по WebDAV — фронтенд должен уметь авторизоваться (или backend отдаёт временную ссылку).
- Все термины и поиск по ним — через обычный SQL-поиск (LIKE) в MySQL.
- PWA: предусмотреть кэширование миниатюр и метаданных для offline-режима, fallback для отсутствия сети.


## Пример архитектуры (схема)

- Vue.js (SPA, PWA)
↔ REST API (Node.js + Express backend)
↔ MySQL (иерархия, термины, сопоставление миниатюр)
↔ WebDAV (PDF, thumbnails)


## Переменная окружения для API (VITE_API_URL)

- Для универсальных запросов к backend API во фронтенде используется переменная окружения `VITE_API_URL`.
- В компонентах Vue.js импортируйте её так:
  ```js
  const apiUrl = import.meta.env.VITE_API_URL || '';
  ```
- Все запросы к API формируйте через этот базовый URL:
  ```js
  axios.get(`${apiUrl}/api/works/files`, { params: { ... } })
  ```
- **В dev-режиме** (локально) переменная может быть пустой, и используется прокси в `vite.config.js` для пересылки `/api` на backend.
- **В production** укажите `VITE_API_URL` в `.env` (например, `VITE_API_URL=https://your-domain.com`), чтобы все запросы шли на нужный сервер.
- Это обеспечивает корректную работу API как в dev, так и в production, и избавляет от необходимости менять код при деплое.


Общая архитектура

- **Frontend:** Vue.js (SPA, PWA), деплоится на Render
- **Backend:** Node.js (Express), деплоится на Render
- **База данных:** MySQL (отдельный хостинг, не Render). В базе хранятся: Вот документации базы данные [TERMS_DB_GUIDE.mdc](mdc:.cursor/rules/TERMS_DB_GUIDE.mdc)
- Иерархия произведений (структура каталога, метаданные, пути к файлам)
- Таблица terms (термины для справочника)
- Таблица сопоставления миниатюр PDF (путь к PDF, путь к миниатюре)
- **Файлы нот и миниатюр:** Хранятся на облачном хранилище WebDAV (cloud.mail.ru)
- Папки с нотами (PDF)
- Папка с миниатюрами (thumbnails)


## Взаимодействие компонентов

- **Vue.js frontend** (SPA, PWA) запрашивает данные у backend (API):
- Получение списка произведений, нот, поиска и т.д.
- Получение списка терминов
- Получение путей к миниатюрам и нотам
- **Backend (Node.js + Express):**
- Получает данные из MySQL (через mysql2 или аналогичный драйвер)
- Отдаёт клиенту только метаданные и пути (не сами файлы)
- Для миниатюр и нот отдаёт клиенту путь для загрузки по WebDAV
- **WebDAV:**
- Фронтенд (или backend-прокси) скачивает PDF/миниатюру по ссылке WebDAV (авторизация через токен/логин)
- Миниатюры лежат в папке thumbnails, имена — md5 от относительного пути к PDF


## Примеры сценариев работы

### 1. Карусель нот конкретного композитора
- Пользователь заходит на сайт (Vue SPA, PWA).
- Фронтенд делает запрос к backend: "дай список произведений Моцарта".
- Backend возвращает массив: [{"title": ..., "composer": ..., "pdf_path": ..., "thumbnail_path": ...}, ...]
- Фронтенд отображает карточки: миниатюра (загружается по WebDAV, путь берётся из thumbnail_path), название, композитор.
- При клике на карточку:
- Фронтенд получает путь к PDF (из базы), загружает файл по WebDAV и открывает во внутреннем просмотрщике (pdf.js).
### 2. Страница терминов
- Пользователь открывает страницу терминов.
- Фронтенд делает запрос к backend: "дай все термины" или "поиск по термину".
- Backend делает SQL-запрос к MySQL, возвращает результаты.
- Фронтенд отображает термины и их описания.


## Используемые технологии

- **Frontend:** Vue.js, pdf.js (для отображения PDF), Tailwind CSS, PWA (Service Worker, Web App Manifest), Vue Router, Axios
- **Backend:** Node.js, Express.js, MySQL2, webdav-client, Axios
- **БД:** MySQL (отдельный хостинг)
- **Файлы:** WebDAV (cloud.mail.ru)
- **Деплой:** Render (frontend, backend), внешний хостинг для MySQL, подключение по WebDAV
- **PWA:** offline режим, установка на устройство, push-уведомления, кэширование статики и API-ответов


## Важные детали для реализации

- Все пути к файлам и миниатюрам в базе — относительные, начинаются с `/`, используют `/` как разделитель.
- Миниатюры не дублируются, поиск по md5 — быстрый (можно строить индекс в памяти или использовать отдельную таблицу в БД).
- Для отдачи 30 миниатюр за раз — backend делает SQL-запрос с LIMIT, отдаёт массив путей к миниатюрам и метаданных.
- Для загрузки файлов по WebDAV — фронтенд должен уметь авторизоваться (или backend отдаёт временную ссылку).
- Все термины и поиск по ним — через обычный SQL-поиск (LIKE) в MySQL.
- PWA: предусмотреть кэширование миниатюр и метаданных для offline-режима, fallback для отсутствия сети.


## Пример архитектуры (схема)

- Vue.js (SPA, PWA)
↔ REST API (Node.js + Express backend)
↔ MySQL (иерархия, термины, сопоставление миниатюр)
↔ WebDAV (PDF, thumbnails)




- Для универсальных запросов к backend API во фронтенде используется переменная окружения `VITE_API_URL`.
- В компонентах Vue.js импортируйте её так:
  ```js
  const apiUrl = import.meta.env.VITE_API_URL || '';
  ```
- Все запросы к API формируйте через этот базовый URL:
  ```js
  axios.get(`${apiUrl}/api/works/files`, { params: { ... } })